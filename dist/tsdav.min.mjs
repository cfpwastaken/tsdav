import e from"debug";import t from"xml-js";import{encode as r}from"base-64";function a(e,t,r,a){if("function"==typeof t?e!==t||!a:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===r?a:"a"===r?a.call(e):a?a.value:t.get(e)}function s(e,t,r,a,s){if("function"==typeof t||!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return t.set(e,r),r}var n,o,c,d;"function"==typeof SuppressedError&&SuppressedError;const i="__TAURI_TO_IPC_KEY__";class l{constructor(e){n.set(this,void 0),o.set(this,0),c.set(this,[]),d.set(this,void 0),s(this,n,e||(()=>{})),this.id=function(e,t=!1){return window.__TAURI_INTERNALS__.transformCallback(e,t)}(e=>{const t=e.index;if("end"in e)return void(t==a(this,o,"f")?this.cleanupCallback():s(this,d,t));const r=e.message;if(t==a(this,o,"f")){for(a(this,n,"f").call(this,r),s(this,o,a(this,o,"f")+1);a(this,o,"f")in a(this,c,"f");){const e=a(this,c,"f")[a(this,o,"f")];a(this,n,"f").call(this,e),delete a(this,c,"f")[a(this,o,"f")],s(this,o,a(this,o,"f")+1)}a(this,o,"f")===a(this,d,"f")&&this.cleanupCallback()}else a(this,c,"f")[t]=r})}cleanupCallback(){window.__TAURI_INTERNALS__.unregisterCallback(this.id)}set onmessage(e){s(this,n,e)}get onmessage(){return a(this,n,"f")}[(n=new WeakMap,o=new WeakMap,c=new WeakMap,d=new WeakMap,i)](){return`__CHANNEL__:${this.id}`}toJSON(){return this[i]()}}async function u(e,t={},r){return window.__TAURI_INTERNALS__.invoke(e,t,r)}const h="Request cancelled";async function p(e,t){const r=t?.signal;if(r?.aborted)throw new Error(h);const a=t?.maxRedirections,s=t?.connectTimeout,n=t?.proxy,o=t?.danger;t&&(delete t.maxRedirections,delete t.connectTimeout,delete t.proxy,delete t.danger);const c=t?.headers?t.headers instanceof Headers?t.headers:new Headers(t.headers):new Headers,d=new Request(e,t),i=await d.arrayBuffer(),p=0!==i.byteLength?Array.from(new Uint8Array(i)):null;for(const[e,t]of d.headers)c.get(e)||c.set(e,t);const f=(c instanceof Headers?Array.from(c.entries()):Array.isArray(c)?c:Object.entries(c)).map(([e,t])=>[e,"string"==typeof t?t:t.toString()]);if(r?.aborted)throw new Error(h);const v=await u("plugin:http|fetch",{clientConfig:{method:d.method,url:d.url,headers:f,data:p,maxRedirections:a,connectTimeout:s,proxy:n,danger:o}}),y=()=>u("plugin:http|fetch_cancel",{rid:v});if(r?.aborted)throw y(),new Error(h);r?.addEventListener("abort",()=>{y()});const{status:m,statusText:O,url:A,headers:w,rid:g}=await u("plugin:http|fetch_send",{rid:v}),b=[101,103,204,205,304].includes(m)?null:new ReadableStream({start:e=>{const t=new l;t.onmessage=t=>{if(r?.aborted)return void e.error(h);const a=new Uint8Array(t),s=a[a.byteLength-1],n=a.slice(0,a.byteLength-1);1!=s?e.enqueue(n):e.close()},u("plugin:http|fetch_read_body",{rid:g,streamChannel:t}).catch(t=>{e.error(t)})}}),C=new Response(b,{status:m,statusText:O});return Object.defineProperty(C,"url",{value:A}),Object.defineProperty(C,"headers",{value:new Headers(w)}),C}var f;!function(e){e.CALENDAR_SERVER="http://calendarserver.org/ns/",e.CALDAV_APPLE="http://apple.com/ns/ical/",e.CALDAV="urn:ietf:params:xml:ns:caldav",e.CARDDAV="urn:ietf:params:xml:ns:carddav",e.DAV="DAV:"}(f||(f={}));const v={[f.CALDAV]:"xmlns:c",[f.CARDDAV]:"xmlns:card",[f.CALENDAR_SERVER]:"xmlns:cs",[f.CALDAV_APPLE]:"xmlns:ca",[f.DAV]:"xmlns:d"};var y,m;!function(e){e.CALDAV="c",e.CARDDAV="card",e.CALENDAR_SERVER="cs",e.CALDAV_APPLE="ca",e.DAV="d"}(y||(y={})),function(e){e.VEVENT="VEVENT",e.VTODO="VTODO",e.VJOURNAL="VJOURNAL",e.VFREEBUSY="VFREEBUSY",e.VTIMEZONE="VTIMEZONE",e.VALARM="VALARM"}(m||(m={}));const O=e=>{const t=Number(e);if(!Number.isNaN(t))return t;const r=e.toLowerCase();return"true"===r||"false"!==r&&e},A=(e,t)=>{if(!e&&!t)return!0;if(!e||!t)return!1;const r=e.trim(),a=t.trim();if(Math.abs(r.length-a.length)>1)return!1;const s="/"===r.slice(-1)?r.slice(0,-1):r,n="/"===a.slice(-1)?a.slice(0,-1):a;return e.includes(n)||t.includes(s)},w=(e,t)=>{if(!e&&!t)return!0;if(!e||!t)return!1;const r=e.trim(),a=t.trim(),s="/"===r.slice(-1)?r.slice(0,-1):r,n="/"===a.slice(-1)?a.slice(0,-1):a;return e.includes(n)||t.includes(s)},g=e=>e.reduce((e,t)=>({...e,[v[t]]:t}),{}),b=e=>Object.entries(e).reduce((e,[t,r])=>r?{...e,[t]:r}:e,{}),C=(e,t)=>t?{[e]:t}:{},D=(e,t)=>e?t&&0!==t.length?Object.fromEntries(Object.entries(e).filter(([e])=>!t.includes(e))):e:{};var V=Object.freeze({__proto__:null,cleanupFalsy:b,conditionalParam:C,excludeHeaders:D,getDAVAttribute:g,urlContains:w,urlEquals:A});const E=e("tsdav:request"),T=async e=>{var r;const{url:a,init:s,convertIncoming:n=!0,parseOutgoing:o=!0,fetchOptions:c={}}=e,{headers:d={},body:i,namespace:l,method:u,attributes:h}=s,f=n?t.js2xml({_declaration:{_attributes:{version:"1.0",encoding:"utf-8"}},...i,_attributes:h},{compact:!0,spaces:2,elementNameFn:e=>l&&!/^.+:.+/.test(e)?`${l}:${e}`:e}):i,v={...c};delete v.headers;const y=await p(a,{headers:{"Content-Type":"text/xml;charset=UTF-8",...b(d),...c.headers||{}},body:f,method:u,...v}),m=await y.text();if(!y.ok||!(null===(r=y.headers.get("content-type"))||void 0===r?void 0:r.includes("xml"))||!o)return[{href:y.url,ok:y.ok,status:y.status,statusText:y.statusText,raw:m}];const A=t.xml2js(m,{compact:!0,trim:!0,textFn:(e,t)=>{try{const r=t._parent,a=Object.keys(r),s=a[a.length-1],n=r[s];if(n.length>0){n[n.length-1]=O(e)}else r[s]=O(e)}catch(e){E(e.stack)}},elementNameFn:e=>e.replace(/^.+:/,"").replace(/([-_]\w)/g,e=>e[1].toUpperCase()),attributesFn:e=>{const t={...e};return delete t.xmlns,t},ignoreDeclaration:!0});return(Array.isArray(A.multistatus.response)?A.multistatus.response:[A.multistatus.response]).map(e=>{var t,r;if(!e)return{status:y.status,statusText:y.statusText,ok:y.ok};const a=/^\S+\s(?<status>\d+)\s(?<statusText>.+)$/.exec(e.status);return{raw:A,href:e.href,status:(null==a?void 0:a.groups)?Number.parseInt(null==a?void 0:a.groups.status,10):y.status,statusText:null!==(r=null===(t=null==a?void 0:a.groups)||void 0===t?void 0:t.statusText)&&void 0!==r?r:y.statusText,ok:!e.error,error:e.error,responsedescription:e.responsedescription,props:(Array.isArray(e.propstat)?e.propstat:[e.propstat]).reduce((e,t)=>({...e,...null==t?void 0:t.prop}),{})}})},$=async e=>{const{url:t,props:r,depth:a,headers:s,headersToExclude:n,fetchOptions:o={}}=e;return T({url:t,init:{method:"PROPFIND",headers:D(b({depth:a,...s}),n),namespace:y.DAV,body:{propfind:{_attributes:g([f.CALDAV,f.CALDAV_APPLE,f.CALENDAR_SERVER,f.CARDDAV,f.DAV]),prop:r}}},fetchOptions:o})},_=async e=>{const{url:t,data:r,headers:a,headersToExclude:s,fetchOptions:n={}}=e;return p(t,{method:"PUT",body:r,headers:D(a,s),...n})},k=async e=>{const{url:t,data:r,etag:a,headers:s,headersToExclude:n,fetchOptions:o={}}=e;return p(t,{method:"PUT",body:r,headers:D(b({"If-Match":a,...s}),n),...o})},R=async e=>{const{url:t,headers:r,etag:a,headersToExclude:s,fetchOptions:n={}}=e;return p(t,{method:"DELETE",headers:D(b({"If-Match":a,...r}),s),...n})};var U=Object.freeze({__proto__:null,createObject:_,davRequest:T,deleteObject:R,propfind:$,updateObject:k});function L(e,t){const r=e=>t.every(t=>e[t]);return Array.isArray(e)?e.every(e=>r(e)):r(e)}const x=(e,t)=>t.reduce((t,r)=>e[r]?t:`${t.length?`${t},`:""}${r.toString()}`,""),S=e("tsdav:collection"),j=async e=>{const{url:t,body:r,depth:a,defaultNamespace:s=y.DAV,headers:n,headersToExclude:o,fetchOptions:c={}}=e,d=await T({url:t,init:{method:"REPORT",headers:D(b({depth:a,...n}),o),namespace:s,body:r},fetchOptions:c});return 1!==d.length||d[0].raw?d:[]},N=async e=>{const{url:t,props:r,depth:a,headers:s,headersToExclude:n,fetchOptions:o={}}=e;return T({url:t,init:{method:"MKCOL",headers:D(b({depth:a,...s}),n),namespace:y.DAV,body:r?{mkcol:{set:{prop:r}}}:void 0},fetchOptions:o})},H=async e=>{var t,r,a,s,n;const{collection:o,headers:c,headersToExclude:d,fetchOptions:i={}}=e;return null!==(n=null===(s=null===(a=null===(r=null===(t=(await $({url:o.url,props:{[`${y.DAV}:supported-report-set`]:{}},depth:"0",headers:D(c,d),fetchOptions:i}))[0])||void 0===t?void 0:t.props)||void 0===r?void 0:r.supportedReportSet)||void 0===a?void 0:a.supportedReport)||void 0===s?void 0:s.map(e=>Object.keys(e.report)[0]))&&void 0!==n?n:[]},P=async e=>{var t,r,a;const{collection:s,headers:n,headersToExclude:o,fetchOptions:c={}}=e,d=(await $({url:s.url,props:{[`${y.CALENDAR_SERVER}:getctag`]:{}},depth:"0",headers:D(n,o),fetchOptions:c})).filter(e=>w(s.url,e.href))[0];if(!d)throw new Error("Collection does not exist on server");return{isDirty:`${s.ctag}`!=`${null===(t=d.props)||void 0===t?void 0:t.getctag}`,newCtag:null===(a=null===(r=d.props)||void 0===r?void 0:r.getctag)||void 0===a?void 0:a.toString()}},I=e=>{const{url:t,props:r,headers:a,syncLevel:s,syncToken:n,headersToExclude:o,fetchOptions:c}=e;return T({url:t,init:{method:"REPORT",namespace:y.DAV,headers:D({...a},o),body:{"sync-collection":{_attributes:g([f.CALDAV,f.CARDDAV,f.DAV]),"sync-level":s,"sync-token":n,[`${y.DAV}:prop`]:r}}},fetchOptions:c})},B=async e=>{var t,r,a,s,n,o,c,d,i,l,u;const{collection:h,method:p,headers:f,headersToExclude:v,account:m,detailedResult:O,fetchOptions:A={}}=e,g=["accountType","homeUrl"];if(!m||!L(m,g)){if(!m)throw new Error("no account for smartCollectionSync");throw new Error(`account must have ${x(m,g)} before smartCollectionSync`)}const b=null!=p?p:(null===(t=h.reports)||void 0===t?void 0:t.includes("syncCollection"))?"webdav":"basic";if(S(`smart collection sync with type ${m.accountType} and method ${b}`),"webdav"===b){const e=await I({url:h.url,props:{[`${y.DAV}:getetag`]:{},[`${"caldav"===m.accountType?y.CALDAV:y.CARDDAV}:${"caldav"===m.accountType?"calendar-data":"address-data"}`]:{},[`${y.DAV}:displayname`]:{}},syncLevel:1,syncToken:h.syncToken,headers:D(f,v),fetchOptions:A}),t=e.filter(e=>{var t;const r="caldav"===m.accountType?".ics":".vcf";return(null===(t=e.href)||void 0===t?void 0:t.slice(-4))===r}),i=t.filter(e=>404!==e.status).map(e=>e.href),l=t.filter(e=>404===e.status).map(e=>e.href),u=(i.length&&null!==(a=await(null===(r=null==h?void 0:h.objectMultiGet)||void 0===r?void 0:r.call(h,{url:h.url,props:{[`${y.DAV}:getetag`]:{},[`${"caldav"===m.accountType?y.CALDAV:y.CARDDAV}:${"caldav"===m.accountType?"calendar-data":"address-data"}`]:{}},objectUrls:i,depth:"1",headers:D(f,v),fetchOptions:A})))&&void 0!==a?a:[]).map(e=>{var t,r,a,s,n,o,c,d,i,l;return{url:null!==(t=e.href)&&void 0!==t?t:"",etag:null===(r=e.props)||void 0===r?void 0:r.getetag,data:"caldav"===(null==m?void 0:m.accountType)?null!==(n=null===(s=null===(a=e.props)||void 0===a?void 0:a.calendarData)||void 0===s?void 0:s._cdata)&&void 0!==n?n:null===(o=e.props)||void 0===o?void 0:o.calendarData:null!==(i=null===(d=null===(c=e.props)||void 0===c?void 0:c.addressData)||void 0===d?void 0:d._cdata)&&void 0!==i?i:null===(l=e.props)||void 0===l?void 0:l.addressData}}),p=null!==(s=h.objects)&&void 0!==s?s:[],g=u.filter(e=>p.every(t=>!w(t.url,e.url))),b=p.reduce((e,t)=>{const r=u.find(e=>w(e.url,t.url));return r&&r.etag&&r.etag!==t.etag?[...e,r]:e},[]),C=l.map(e=>({url:e,etag:""})),V=p.filter(e=>u.some(t=>w(e.url,t.url)&&t.etag===e.etag));return{...h,objects:O?{created:g,updated:b,deleted:C}:[...V,...g,...b],syncToken:null!==(d=null===(c=null===(o=null===(n=e[0])||void 0===n?void 0:n.raw)||void 0===o?void 0:o.multistatus)||void 0===c?void 0:c.syncToken)&&void 0!==d?d:h.syncToken}}if("basic"===b){const{isDirty:e,newCtag:t}=await P({collection:h,headers:D(f,v),fetchOptions:A}),r=null!==(i=h.objects)&&void 0!==i?i:[],a=null!==(u=await(null===(l=h.fetchObjects)||void 0===l?void 0:l.call(h,{collection:h,headers:D(f,v),fetchOptions:A})))&&void 0!==u?u:[],s=a.filter(e=>r.every(t=>!w(t.url,e.url))),n=r.reduce((e,t)=>{const r=a.find(e=>w(e.url,t.url));return r&&r.etag&&r.etag!==t.etag?[...e,r]:e},[]),o=r.filter(e=>a.every(t=>!w(t.url,e.url))),c=r.filter(e=>a.some(t=>w(e.url,t.url)&&t.etag===e.etag));if(e)return{...h,objects:O?{created:s,updated:n,deleted:o}:[...c,...s,...n],ctag:t}}return O?{...h,objects:{created:[],updated:[],deleted:[]}}:h};var M=Object.freeze({__proto__:null,collectionQuery:j,isCollectionDirty:P,makeCollection:N,smartCollectionSync:B,supportedReportSet:H,syncCollection:I});const F=e("tsdav:addressBook"),z=async e=>{const{url:t,props:r,filters:a,depth:s,headers:n,headersToExclude:o,fetchOptions:c={}}=e;return j({url:t,body:{"addressbook-query":b({_attributes:g([f.CARDDAV,f.DAV]),[`${y.DAV}:prop`]:r,filter:null!=a?a:{"prop-filter":{_attributes:{name:"FN"}}}})},defaultNamespace:y.CARDDAV,depth:s,headers:D(n,o),fetchOptions:c})},Z=async e=>{const{url:t,props:r,objectUrls:a,depth:s,headers:n,headersToExclude:o,fetchOptions:c={}}=e;return j({url:t,body:{"addressbook-multiget":b({_attributes:g([f.DAV,f.CARDDAV]),[`${y.DAV}:prop`]:r,[`${y.DAV}:href`]:a})},defaultNamespace:y.CARDDAV,depth:s,headers:D(n,o),fetchOptions:c})},q=async e=>{const{account:t,headers:r,props:a,headersToExclude:s,fetchOptions:n={}}=null!=e?e:{},o=["homeUrl","rootUrl"];if(!t||!L(t,o)){if(!t)throw new Error("no account for fetchAddressBooks");throw new Error(`account must have ${x(t,o)} before fetchAddressBooks`)}const c=await $({url:t.homeUrl,props:null!=a?a:{[`${y.DAV}:displayname`]:{},[`${y.CALENDAR_SERVER}:getctag`]:{},[`${y.DAV}:resourcetype`]:{},[`${y.DAV}:sync-token`]:{}},depth:"1",headers:D(r,s),fetchOptions:n});return Promise.all(c.filter(e=>{var t,r;return Object.keys(null!==(r=null===(t=e.props)||void 0===t?void 0:t.resourcetype)&&void 0!==r?r:{}).includes("addressbook")}).map(e=>{var r,a,s,n,o,c,d,i,l;const u=null!==(s=null===(a=null===(r=e.props)||void 0===r?void 0:r.displayname)||void 0===a?void 0:a._cdata)&&void 0!==s?s:null===(n=e.props)||void 0===n?void 0:n.displayname;return F(`Found address book named ${"string"==typeof u?u:""},\n             props: ${JSON.stringify(e.props)}`),{url:new URL(null!==(o=e.href)&&void 0!==o?o:"",null!==(c=t.rootUrl)&&void 0!==c?c:"").href,ctag:null===(d=e.props)||void 0===d?void 0:d.getctag,displayName:"string"==typeof u?u:"",resourcetype:Object.keys(null===(i=e.props)||void 0===i?void 0:i.resourcetype),syncToken:null===(l=e.props)||void 0===l?void 0:l.syncToken}}).map(async e=>({...e,reports:await H({collection:e,headers:D(r,s),fetchOptions:n})})))},G=async e=>{const{addressBook:t,headers:r,objectUrls:a,headersToExclude:s,urlFilter:n=e=>e,useMultiGet:o=!0,fetchOptions:c={}}=e;F(`Fetching vcards from ${null==t?void 0:t.url}`);const d=["url"];if(!t||!L(t,d)){if(!t)throw new Error("cannot fetchVCards for undefined addressBook");throw new Error(`addressBook must have ${x(t,d)} before fetchVCards`)}const i=(null!=a?a:(await z({url:t.url,props:{[`${y.DAV}:getetag`]:{}},depth:"1",headers:D(r,s),fetchOptions:c})).map(e=>{var t;return e.ok&&null!==(t=e.href)&&void 0!==t?t:""})).map(e=>e.startsWith("http")||!e?e:new URL(e,t.url).href).filter(n).map(e=>new URL(e).pathname);let l=[];return i.length>0&&(l=o?await Z({url:t.url,props:{[`${y.DAV}:getetag`]:{},[`${y.CARDDAV}:address-data`]:{}},objectUrls:i,depth:"1",headers:D(r,s),fetchOptions:c}):await z({url:t.url,props:{[`${y.DAV}:getetag`]:{},[`${y.CARDDAV}:address-data`]:{}},depth:"1",headers:D(r,s),fetchOptions:c})),l.map(e=>{var r,a,s,n,o,c;return{url:new URL(null!==(r=e.href)&&void 0!==r?r:"",t.url).href,etag:null===(a=e.props)||void 0===a?void 0:a.getetag,data:null!==(o=null===(n=null===(s=e.props)||void 0===s?void 0:s.addressData)||void 0===n?void 0:n._cdata)&&void 0!==o?o:null===(c=e.props)||void 0===c?void 0:c.addressData}})},Q=async e=>{const{addressBook:t,vCardString:r,filename:a,headers:s,headersToExclude:n,fetchOptions:o={}}=e;return _({url:new URL(a,t.url).href,data:r,headers:D({"content-type":"text/vcard; charset=utf-8","If-None-Match":"*",...s},n),fetchOptions:o})},W=async e=>{const{vCard:t,headers:r,headersToExclude:a,fetchOptions:s={}}=e;return k({url:t.url,data:t.data,etag:t.etag,headers:D({"content-type":"text/vcard; charset=utf-8",...r},a),fetchOptions:s})},J=async e=>{const{vCard:t,headers:r,headersToExclude:a,fetchOptions:s={}}=e;return R({url:t.url,etag:t.etag,headers:D(r,a),fetchOptions:s})};var K=Object.freeze({__proto__:null,addressBookMultiGet:Z,addressBookQuery:z,createVCard:Q,deleteVCard:J,fetchAddressBooks:q,fetchVCards:G,updateVCard:W});const Y=e("tsdav:calendar"),X=async e=>{var t,r,a;const{account:s,headers:n,headersToExclude:o,fetchOptions:c={}}=e,d=["principalUrl","rootUrl"];if(!L(s,d))throw new Error(`account must have ${x(s,d)} before fetchUserAddresses`);Y(`Fetch user addresses from ${s.principalUrl}`);const i=(await $({url:s.principalUrl,props:{[`${y.CALDAV}:calendar-user-address-set`]:{}},depth:"0",headers:D(n,o),fetchOptions:c})).find(e=>w(s.principalUrl,e.href));if(!i||!i.ok)throw new Error("cannot find calendarUserAddresses");const l=(null===(a=null===(r=null===(t=null==i?void 0:i.props)||void 0===t?void 0:t.calendarUserAddressSet)||void 0===r?void 0:r.href)||void 0===a?void 0:a.filter(Boolean))||[];return Y(`Fetched calendar user addresses ${l}`),l},ee=async e=>{const{url:t,props:r,filters:a,timezone:s,depth:n,headers:o,headersToExclude:c,fetchOptions:d={}}=e;return j({url:t,body:{"calendar-query":b({_attributes:g([f.CALDAV,f.CALENDAR_SERVER,f.CALDAV_APPLE,f.DAV]),[`${y.DAV}:prop`]:r,filter:a,timezone:s})},defaultNamespace:y.CALDAV,depth:n,headers:D(o,c),fetchOptions:d})},te=async e=>{const{url:t,props:r,objectUrls:a,filters:s,timezone:n,depth:o,headers:c,headersToExclude:d,fetchOptions:i={}}=e;return j({url:t,body:{"calendar-multiget":b({_attributes:g([f.DAV,f.CALDAV]),[`${y.DAV}:prop`]:r,[`${y.DAV}:href`]:a,filter:s,timezone:n})},defaultNamespace:y.CALDAV,depth:o,headers:D(c,d),fetchOptions:i})},re=async e=>{const{url:t,props:r,depth:a,headers:s,headersToExclude:n,fetchOptions:o={}}=e;return T({url:t,init:{method:"MKCALENDAR",headers:D(b({depth:a,...s}),n),namespace:y.DAV,body:{[`${y.CALDAV}:mkcalendar`]:{_attributes:g([f.DAV,f.CALDAV,f.CALDAV_APPLE]),set:{prop:r}}}},fetchOptions:o})},ae=async e=>{const{headers:t,account:r,props:a,projectedProps:s,headersToExclude:n,fetchOptions:o={}}=null!=e?e:{},c=["homeUrl","rootUrl"];if(!r||!L(r,c)){if(!r)throw new Error("no account for fetchCalendars");throw new Error(`account must have ${x(r,c)} before fetchCalendars`)}const d=await $({url:r.homeUrl,props:null!=a?a:{[`${y.CALDAV}:calendar-description`]:{},[`${y.CALDAV}:calendar-timezone`]:{},[`${y.DAV}:displayname`]:{},[`${y.CALDAV_APPLE}:calendar-color`]:{},[`${y.CALENDAR_SERVER}:getctag`]:{},[`${y.DAV}:resourcetype`]:{},[`${y.CALDAV}:supported-calendar-component-set`]:{},[`${y.DAV}:sync-token`]:{}},depth:"1",headers:D(t,n),fetchOptions:o});return Promise.all(d.filter(e=>{var t,r;return Object.keys(null!==(r=null===(t=e.props)||void 0===t?void 0:t.resourcetype)&&void 0!==r?r:{}).includes("calendar")}).filter(e=>{var t,r,a,s,n,o;return(Array.isArray(null===(r=null===(t=e.props)||void 0===t?void 0:t.supportedCalendarComponentSet)||void 0===r?void 0:r.comp)?null===(a=e.props)||void 0===a?void 0:a.supportedCalendarComponentSet.comp.map(e=>e._attributes.name):[null===(o=null===(n=null===(s=e.props)||void 0===s?void 0:s.supportedCalendarComponentSet)||void 0===n?void 0:n.comp)||void 0===o?void 0:o._attributes.name]).some(e=>Object.values(m).includes(e))}).map(e=>{var t,a,n,o,c,d,i,l,u,h,p,f,v,y,m,O;const A=null===(t=e.props)||void 0===t?void 0:t.calendarDescription,w=null===(a=e.props)||void 0===a?void 0:a.calendarTimezone;return{description:"string"==typeof A?A:"",timezone:"string"==typeof w?w:"",url:new URL(null!==(n=e.href)&&void 0!==n?n:"",null!==(o=r.rootUrl)&&void 0!==o?o:"").href,ctag:null===(c=e.props)||void 0===c?void 0:c.getctag,calendarColor:null===(d=e.props)||void 0===d?void 0:d.calendarColor,displayName:null!==(l=null===(i=e.props)||void 0===i?void 0:i.displayname._cdata)&&void 0!==l?l:null===(u=e.props)||void 0===u?void 0:u.displayname,components:Array.isArray(null===(h=e.props)||void 0===h?void 0:h.supportedCalendarComponentSet.comp)?null===(p=e.props)||void 0===p?void 0:p.supportedCalendarComponentSet.comp.map(e=>e._attributes.name):[null===(v=null===(f=e.props)||void 0===f?void 0:f.supportedCalendarComponentSet.comp)||void 0===v?void 0:v._attributes.name],resourcetype:Object.keys(null===(y=e.props)||void 0===y?void 0:y.resourcetype),syncToken:null===(m=e.props)||void 0===m?void 0:m.syncToken,...C("projectedProps",Object.fromEntries(Object.entries(null!==(O=e.props)&&void 0!==O?O:{}).filter(([e])=>null==s?void 0:s[e])))}}).map(async e=>({...e,reports:await H({collection:e,headers:D(t,n),fetchOptions:o})})))},se=async e=>{const{calendar:t,objectUrls:r,filters:a,timeRange:s,headers:n,expand:o,urlFilter:c=e=>Boolean(null==e?void 0:e.includes(".ics")),useMultiGet:d=!0,headersToExclude:i,fetchOptions:l={}}=e;if(s){const e=/^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?)?)?)?$/i,t=/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i;if(!(e.test(s.start)&&e.test(s.end)||t.test(s.start)&&t.test(s.end)))throw new Error("invalid timeRange format, not in ISO8601")}Y(`Fetching calendar objects from ${null==t?void 0:t.url}`);const u=["url"];if(!t||!L(t,u)){if(!t)throw new Error("cannot fetchCalendarObjects for undefined calendar");throw new Error(`calendar must have ${x(t,u)} before fetchCalendarObjects`)}const h=null!=a?a:[{"comp-filter":{_attributes:{name:"VCALENDAR"},"comp-filter":{_attributes:{name:"VEVENT"},...s?{"time-range":{_attributes:{start:`${new Date(s.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(s.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}}:{}}}}],p=(null!=r?r:(await ee({url:t.url,props:{[`${y.DAV}:getetag`]:{...o&&s?{[`${y.CALDAV}:expand`]:{_attributes:{start:`${new Date(s.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(s.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}}:{}}},filters:h,depth:"1",headers:D(n,i),fetchOptions:l})).map(e=>{var t;return null!==(t=e.href)&&void 0!==t?t:""})).map(e=>e.startsWith("http")||!e?e:new URL(e,t.url).href).filter(c).map(e=>new URL(e).pathname);let f=[];return p.length>0&&(f=!d||o?await ee({url:t.url,props:{[`${y.DAV}:getetag`]:{},[`${y.CALDAV}:calendar-data`]:{...o&&s?{[`${y.CALDAV}:expand`]:{_attributes:{start:`${new Date(s.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(s.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}}:{}}},filters:h,depth:"1",headers:D(n,i),fetchOptions:l}):await te({url:t.url,props:{[`${y.DAV}:getetag`]:{},[`${y.CALDAV}:calendar-data`]:{...o&&s?{[`${y.CALDAV}:expand`]:{_attributes:{start:`${new Date(s.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(s.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}}:{}}},objectUrls:p,depth:"1",headers:D(n,i),fetchOptions:l})),f.map(e=>{var r,a,s,n,o,c;return{url:new URL(null!==(r=e.href)&&void 0!==r?r:"",t.url).href,etag:`${null===(a=e.props)||void 0===a?void 0:a.getetag}`,data:null!==(o=null===(n=null===(s=e.props)||void 0===s?void 0:s.calendarData)||void 0===n?void 0:n._cdata)&&void 0!==o?o:null===(c=e.props)||void 0===c?void 0:c.calendarData}})},ne=async e=>{const{calendar:t,iCalString:r,filename:a,headers:s,headersToExclude:n,fetchOptions:o={}}=e;return _({url:new URL(a,t.url).href,data:r,headers:D({"content-type":"text/calendar; charset=utf-8","If-None-Match":"*",...s},n),fetchOptions:o})},oe=async e=>{const{calendarObject:t,headers:r,headersToExclude:a,fetchOptions:s={}}=e;return k({url:t.url,data:t.data,etag:t.etag,headers:D({"content-type":"text/calendar; charset=utf-8",...r},a),fetchOptions:s})},ce=async e=>{const{calendarObject:t,headers:r,headersToExclude:a,fetchOptions:s={}}=e;return R({url:t.url,etag:t.etag,headers:D(r,a),fetchOptions:s})},de=async e=>{var t;const{oldCalendars:r,account:a,detailedResult:s,headers:n,headersToExclude:o,fetchOptions:c={}}=e;if(!a)throw new Error("Must have account before syncCalendars");const d=null!==(t=null!=r?r:a.calendars)&&void 0!==t?t:[],i=await ae({account:a,headers:D(n,o),fetchOptions:c}),l=i.filter(e=>d.every(t=>!w(t.url,e.url)));Y(`new calendars: ${l.map(e=>e.displayName)}`);const u=d.reduce((e,t)=>{const r=i.find(e=>w(e.url,t.url));return r&&(r.syncToken&&`${r.syncToken}`!=`${t.syncToken}`||r.ctag&&`${r.ctag}`!=`${t.ctag}`)?[...e,r]:e},[]);Y(`updated calendars: ${u.map(e=>e.displayName)}`);const h=await Promise.all(u.map(async e=>await B({collection:{...e,objectMultiGet:te},method:"webdav",headers:D(n,o),account:a,fetchOptions:c}))),p=d.filter(e=>i.every(t=>!w(t.url,e.url)));Y(`deleted calendars: ${p.map(e=>e.displayName)}`);const f=d.filter(e=>i.some(t=>w(t.url,e.url)&&(t.syncToken&&`${t.syncToken}`!=`${e.syncToken}`||t.ctag&&`${t.ctag}`!=`${e.ctag}`)));return s?{created:l,updated:u,deleted:p}:[...f,...l,...h]},ie=async e=>{const{url:t,timeRange:r,depth:a,headers:s,headersToExclude:n,fetchOptions:o={}}=e;if(!r)throw new Error("timeRange is required");{const e=/^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?)?)?)?$/i,t=/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i;if(!(e.test(r.start)&&e.test(r.end)||t.test(r.start)&&t.test(r.end)))throw new Error("invalid timeRange format, not in ISO8601")}return(await j({url:t,body:{"free-busy-query":b({_attributes:g([f.CALDAV]),[`${y.CALDAV}:time-range`]:{_attributes:{start:`${new Date(r.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(r.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}})},defaultNamespace:y.CALDAV,depth:a,headers:D(s,n),fetchOptions:o}))[0]};var le=Object.freeze({__proto__:null,calendarMultiGet:te,calendarQuery:ee,createCalendarObject:ne,deleteCalendarObject:ce,fetchCalendarObjects:se,fetchCalendarUserAddresses:X,fetchCalendars:ae,freeBusyQuery:ie,makeCalendar:re,syncCalendars:de,updateCalendarObject:oe});const ue=e("tsdav:account"),he=async e=>{var t,r;ue("Service discovery...");const{account:a,headers:s,headersToExclude:n,fetchOptions:o={}}=e,c=new URL(a.serverUrl),d=new URL(`/.well-known/${a.accountType}`,c);d.protocol=null!==(t=c.protocol)&&void 0!==t?t:"http";try{const e=await p(d.href,{headers:D(s,n),method:"PROPFIND",redirect:"manual",...o});if(e.status>=300&&e.status<400){const t=e.headers.get("Location");if("string"==typeof t&&t.length){ue(`Service discovery redirected to ${t}`);const e=new URL(t,c);return e.hostname===d.hostname&&d.port&&!e.port&&(e.port=d.port),e.protocol=null!==(r=c.protocol)&&void 0!==r?r:"http",e.href}}}catch(e){ue(`Service discovery failed: ${e.stack}`)}return c.href},pe=async e=>{var t,r,a,s,n;const{account:o,headers:c,headersToExclude:d,fetchOptions:i={}}=e,l=["rootUrl"];if(!L(o,l))throw new Error(`account must have ${x(o,l)} before fetchPrincipalUrl`);ue(`Fetching principal url from path ${o.rootUrl}`);const[u]=await $({url:o.rootUrl,props:{[`${y.DAV}:current-user-principal`]:{}},depth:"0",headers:D(c,d),fetchOptions:i});if(!u.ok&&(ue(`Fetch principal url failed: ${u.statusText}`),401===u.status))throw new Error("Invalid credentials");return ue(`Fetched principal url ${null===(r=null===(t=u.props)||void 0===t?void 0:t.currentUserPrincipal)||void 0===r?void 0:r.href}`),new URL(null!==(n=null===(s=null===(a=u.props)||void 0===a?void 0:a.currentUserPrincipal)||void 0===s?void 0:s.href)&&void 0!==n?n:"",o.rootUrl).href},fe=async e=>{var t,r;const{account:a,headers:s,headersToExclude:n,fetchOptions:o={}}=e,c=["principalUrl","rootUrl"];if(!L(a,c))throw new Error(`account must have ${x(a,c)} before fetchHomeUrl`);ue(`Fetch home url from ${a.principalUrl}`);const d=await $({url:a.principalUrl,props:"caldav"===a.accountType?{[`${y.CALDAV}:calendar-home-set`]:{}}:{[`${y.CARDDAV}:addressbook-home-set`]:{}},depth:"0",headers:D(s,n),fetchOptions:o}),i=d.find(e=>w(a.principalUrl,e.href));if(!i||!i.ok)throw ue(`Fetch home url failed with status ${null==i?void 0:i.statusText} and error ${JSON.stringify(d.map(e=>e.error))}`),new Error("cannot find homeUrl");const l=new URL("caldav"===a.accountType?null===(t=null==i?void 0:i.props)||void 0===t?void 0:t.calendarHomeSet.href:null===(r=null==i?void 0:i.props)||void 0===r?void 0:r.addressbookHomeSet.href,a.rootUrl).href;return ue(`Fetched home url ${l}`),l},ve=async e=>{const{account:t,headers:r,loadCollections:a=!1,loadObjects:s=!1,headersToExclude:n,fetchOptions:o={}}=e,c={...t};return c.rootUrl=await he({account:t,headers:D(r,n),fetchOptions:o}),c.principalUrl=await pe({account:c,headers:D(r,n),fetchOptions:o}),c.homeUrl=await fe({account:c,headers:D(r,n),fetchOptions:o}),(a||s)&&("caldav"===t.accountType?c.calendars=await ae({headers:D(r,n),account:c,fetchOptions:o}):"carddav"===t.accountType&&(c.addressBooks=await q({headers:D(r,n),account:c,fetchOptions:o}))),s&&("caldav"===t.accountType&&c.calendars?c.calendars=await Promise.all(c.calendars.map(async e=>({...e,objects:await se({calendar:e,headers:D(r,n),fetchOptions:o})}))):"carddav"===t.accountType&&c.addressBooks&&(c.addressBooks=await Promise.all(c.addressBooks.map(async e=>({...e,objects:await G({addressBook:e,headers:D(r,n),fetchOptions:o})}))))),c};var ye=Object.freeze({__proto__:null,createAccount:ve,fetchHomeUrl:fe,fetchPrincipalUrl:pe,serviceDiscovery:he});const me=e("tsdav:authHelper"),Oe=(e,t)=>(...r)=>e({...t,...r[0]}),Ae=e=>(me(`Basic auth token generated: ${r(`${e.username}:${e.password}`)}`),{authorization:`Basic ${r(`${e.username}:${e.password}`)}`}),we=async(e,t)=>{const r=["authorizationCode","redirectUrl","clientId","clientSecret","tokenUrl"];if(!L(e,r))throw new Error(`Oauth credentials missing: ${x(e,r)}`);const a=new URLSearchParams({grant_type:"authorization_code",code:e.authorizationCode,redirect_uri:e.redirectUrl,client_id:e.clientId,client_secret:e.clientSecret});me(e.tokenUrl),me(a.toString());const s=await p(e.tokenUrl,{method:"POST",body:a.toString(),headers:{"content-length":`${a.toString().length}`,"content-type":"application/x-www-form-urlencoded"},...null!=t?t:{}});if(s.ok){return await s.json()}return me(`Fetch Oauth tokens failed: ${await s.text()}`),{}},ge=async(e,t)=>{const r=["refreshToken","clientId","clientSecret","tokenUrl"];if(!L(e,r))throw new Error(`Oauth credentials missing: ${x(e,r)}`);const a=new URLSearchParams({client_id:e.clientId,client_secret:e.clientSecret,refresh_token:e.refreshToken,grant_type:"refresh_token"}),s=await p(e.tokenUrl,{method:"POST",body:a.toString(),headers:{"Content-Type":"application/x-www-form-urlencoded"},...null!=t?t:{}});if(s.ok){return await s.json()}return me(`Refresh access token failed: ${await s.text()}`),{}},be=async(e,t)=>{var r;me("Fetching oauth headers");let a={};return e.refreshToken?(e.refreshToken&&!e.accessToken||Date.now()>(null!==(r=e.expiration)&&void 0!==r?r:0))&&(a=await ge(e,t)):a=await we(e,t),me(`Oauth tokens fetched: ${a.access_token}`),{tokens:a,headers:{authorization:`Bearer ${a.access_token}`}}};var Ce=Object.freeze({__proto__:null,defaultParam:Oe,fetchOauthTokens:we,getBasicAuthHeaders:Ae,getOauthHeaders:be,refreshAccessToken:ge});const De=async e=>{var t;const{serverUrl:r,credentials:a,authMethod:s,defaultAccountType:n,authFunction:o}=e;let c={};switch(s){case"Basic":c=Ae(a);break;case"Oauth":c=(await be(a)).headers;break;case"Digest":c={Authorization:`Digest ${a.digestString}`};break;case"Custom":c=null!==(t=await(null==o?void 0:o(a)))&&void 0!==t?t:{};break;default:throw new Error("Invalid auth method")}const d=n?await ve({account:{serverUrl:r,credentials:a,accountType:n},headers:c}):void 0,i=Oe(_,{url:r,headers:c}),l=Oe(k,{headers:c,url:r}),u=Oe(R,{headers:c,url:r}),h=Oe($,{headers:c}),p=Oe(j,{headers:c}),f=Oe(N,{headers:c}),v=Oe(I,{headers:c}),y=Oe(H,{headers:c}),m=Oe(P,{headers:c}),O=Oe(B,{headers:c,account:d}),A=Oe(ee,{headers:c}),w=Oe(te,{headers:c}),g=Oe(re,{headers:c}),b=Oe(ae,{headers:c,account:d}),C=Oe(X,{headers:c,account:d}),D=Oe(se,{headers:c}),V=Oe(ne,{headers:c}),E=Oe(oe,{headers:c}),U=Oe(ce,{headers:c}),L=Oe(de,{account:d,headers:c}),x=Oe(z,{headers:c}),S=Oe(Z,{headers:c});return{davRequest:async e=>{const{init:t,...r}=e,{headers:a,...s}=t;return T({...r,init:{...s,headers:{...c,...a}}})},propfind:h,createAccount:async e=>{const{account:t,headers:s,loadCollections:n,loadObjects:o}=e;return ve({account:{serverUrl:r,credentials:a,...t},headers:{...c,...s},loadCollections:n,loadObjects:o})},createObject:i,updateObject:l,deleteObject:u,calendarQuery:A,addressBookQuery:x,collectionQuery:p,makeCollection:f,calendarMultiGet:w,makeCalendar:g,syncCollection:v,supportedReportSet:y,isCollectionDirty:m,smartCollectionSync:O,fetchCalendars:b,fetchCalendarUserAddresses:C,fetchCalendarObjects:D,createCalendarObject:V,updateCalendarObject:E,deleteCalendarObject:U,syncCalendars:L,fetchAddressBooks:Oe(q,{account:d,headers:c}),addressBookMultiGet:S,fetchVCards:Oe(G,{headers:c}),createVCard:Oe(Q,{headers:c}),updateVCard:Oe(W,{headers:c}),deleteVCard:Oe(J,{headers:c})}};class Ve{constructor(e){var t,r,a;this.serverUrl=e.serverUrl,this.credentials=e.credentials,this.authMethod=null!==(t=e.authMethod)&&void 0!==t?t:"Basic",this.accountType=null!==(r=e.defaultAccountType)&&void 0!==r?r:"caldav",this.authFunction=e.authFunction,this.fetchOptions=null!==(a=e.fetchOptions)&&void 0!==a?a:{}}async login(){var e;switch(this.authMethod){case"Basic":this.authHeaders=Ae(this.credentials);break;case"Oauth":this.authHeaders=(await be(this.credentials,this.fetchOptions)).headers;break;case"Digest":this.authHeaders={Authorization:`Digest ${this.credentials.digestString}`};break;case"Custom":this.authHeaders=await(null===(e=this.authFunction)||void 0===e?void 0:e.call(this,this.credentials));break;default:throw new Error("Invalid auth method")}this.account=this.accountType?await ve({account:{serverUrl:this.serverUrl,credentials:this.credentials,accountType:this.accountType},headers:this.authHeaders,fetchOptions:this.fetchOptions}):void 0}async davRequest(e){const{init:t,...r}=e,{headers:a,...s}=t;return T({...r,init:{...s,headers:{...this.authHeaders,...a}},fetchOptions:this.fetchOptions})}async createObject(...e){return Oe(_,{url:this.serverUrl,headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async updateObject(...e){return Oe(k,{url:this.serverUrl,headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async deleteObject(...e){return Oe(R,{url:this.serverUrl,headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async propfind(...e){return Oe($,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async createAccount(e){const{account:t,headers:r,loadCollections:a,loadObjects:s,fetchOptions:n}=e;return ve({account:{serverUrl:this.serverUrl,credentials:this.credentials,...t},headers:{...this.authHeaders,...r},loadCollections:a,loadObjects:s,fetchOptions:null!=n?n:this.fetchOptions})}async collectionQuery(...e){return Oe(j,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async makeCollection(...e){return Oe(N,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async syncCollection(...e){return Oe(I,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async supportedReportSet(...e){return Oe(H,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async isCollectionDirty(...e){return Oe(P,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async smartCollectionSync(...e){return Oe(B,{headers:this.authHeaders,fetchOptions:this.fetchOptions,account:this.account})(e[0])}async calendarQuery(...e){return Oe(ee,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async makeCalendar(...e){return Oe(re,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async calendarMultiGet(...e){return Oe(te,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async fetchCalendars(...e){return Oe(ae,{headers:this.authHeaders,account:this.account,fetchOptions:this.fetchOptions})(null==e?void 0:e[0])}async fetchCalendarUserAddresses(...e){return Oe(X,{headers:this.authHeaders,account:this.account,fetchOptions:this.fetchOptions})(null==e?void 0:e[0])}async fetchCalendarObjects(...e){return Oe(se,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async createCalendarObject(...e){return Oe(ne,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async updateCalendarObject(...e){return Oe(oe,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async deleteCalendarObject(...e){return Oe(ce,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async syncCalendars(...e){return Oe(de,{headers:this.authHeaders,account:this.account,fetchOptions:this.fetchOptions})(e[0])}async addressBookQuery(...e){return Oe(z,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async addressBookMultiGet(...e){return Oe(Z,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async fetchAddressBooks(...e){return Oe(q,{headers:this.authHeaders,account:this.account,fetchOptions:this.fetchOptions})(null==e?void 0:e[0])}async fetchVCards(...e){return Oe(G,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async createVCard(...e){return Oe(Q,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async updateVCard(...e){return Oe(W,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async deleteVCard(...e){return Oe(J,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}}var Ee={DAVNamespace:f,DAVNamespaceShort:y,DAVAttributeMap:v,...Object.freeze({__proto__:null,DAVClient:Ve,createDAVClient:De}),...U,...M,...ye,...K,...le,...Ce,...V};export{v as DAVAttributeMap,Ve as DAVClient,f as DAVNamespace,y as DAVNamespaceShort,Z as addressBookMultiGet,z as addressBookQuery,te as calendarMultiGet,ee as calendarQuery,b as cleanupFalsy,j as collectionQuery,ve as createAccount,ne as createCalendarObject,De as createDAVClient,_ as createObject,Q as createVCard,T as davRequest,Ee as default,ce as deleteCalendarObject,R as deleteObject,J as deleteVCard,q as fetchAddressBooks,se as fetchCalendarObjects,X as fetchCalendarUserAddresses,ae as fetchCalendars,we as fetchOauthTokens,G as fetchVCards,ie as freeBusyQuery,Ae as getBasicAuthHeaders,g as getDAVAttribute,be as getOauthHeaders,P as isCollectionDirty,re as makeCalendar,$ as propfind,ge as refreshAccessToken,B as smartCollectionSync,H as supportedReportSet,de as syncCalendars,I as syncCollection,oe as updateCalendarObject,k as updateObject,W as updateVCard,w as urlContains,A as urlEquals};
